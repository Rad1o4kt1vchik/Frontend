In the imperative jQuery version, the UI change is described as a sequence of DOM operations: on button click we select the paragraph element and toggle a CSS class using `toggleClass`. This approach is “step-by-step”: the developer must explicitly tell the browser what to modify and when. The code directly touches the DOM, so the logic is tightly coupled to element IDs and the current document structure.

In the declarative React version, the UI is expressed as a function of state. We store a boolean `isHighlighted` in component state and compute the paragraph `className` from that state. When the user clicks the button, we do not mutate the DOM ourselves; we only update state with `setIsHighlighted`. React then re-renders the component and ensures the real DOM matches the desired UI described by JSX. This is the key shift described in Chapter 1: instead of imperative DOM steps, we describe the UI structure for each state and let React handle updates.

React can do this efficiently because it uses a virtual DOM representation and performs diffing: it compares the previous UI output with the new output after state changes, then patches only the minimal DOM updates needed. That means as “data changes over time”, we keep writing predictable UI descriptions, not complex sequences of DOM calls.

The declarative approach scales better because adding more UI states and elements usually means adding more state and conditional rendering, not more manual DOM selectors and updates. In larger apps, imperative code often becomes fragile (many scattered DOM updates), while React’s state-driven rendering centralizes UI logic and makes behavior easier to reason about and maintain.
